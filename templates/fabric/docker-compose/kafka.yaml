  kafka{{INDEX}}:
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure
        delay: 5s
      placement:
        constraints:
          - node.hostname == {{MACHINE_NAME}}
    image: hyperledger/fabric-kafka:${DEPEND_IMAGE_TAG}
    command: /opt/kafka/bin/kafka-server-start.sh
    # ports:
    #   - "{{(INDEX*10+9092)}}:9092"  # kafka 默认监听端口
    environment:
      - KAFKA_MESSAGE_MAX_BYTES=103809024
      - KAFKA_REPLICA_FETCH_MAX_BYTES=103809024
      - KAFKA_UNCLEAN_LEADER_ELECTION_ENABLE=false
      - KAFKA_MIN_INSYNC_REPLICAS=2
      - KAFKA_DEFAULT_REPLICATION_FACTOR=3
      - KAFKA_BROKER_ID={{INDEX}}
      - KAFKA_ZOOKEEPER_CONNECT={{KAFKA_ZOOKEEPER_CONNECT}}
      # - KAFKA_ZOOKEEPER_CONNECTION_TIMEOUT_MS = 6000
      # - KAFKA_ZOOKEEPER_SESSION_TIMEOUT_MS = 6000
# 使用 swarm overlay 网络，暴露出来的端口号不能重复（与单机情况等同）
# swarm 集群的每个 docker 主机上会创建两个新网络
#     overlay 网络
#         容器间进行跨主机（主机的 hostname 唯一）通信的网络
#         不改变现有网络基础设施，通过某种约定通信协议，把二层报文封装在 IP 报文之上
#         一代 Swarm 已经不再使用，它要求使用 overlay 网络前先准备好分布式键值库(etcd/consul/zookeeper)
#         二代 Docker Swarm Mode，只要 init 建立集群，其它节点 join 后，集群内的服务就自动建立了 overlay 网络互联能力
#     bridge 网络
#         将单个的 docker 守护进程连接到 swarm 中的其他守护进程
    # hostname: kafka{{INDEX}}.{{ORDERERS_DOMAIN}}.com
    # container_name: kafka{{INDEX}}.{{ORDERERS_DOMAIN}}.com
# docker 网络中的容器通过查找 `服务名/别名` 访问其它容器
# 使用 docker stack deploy 时
#     container_name 字段无效，服务名自动赋值为 `前缀_服务_编号`
#     `服务名` 不能含 `.` ，所以通常依赖 `别名` 来发现服务
# 使用 docker-compose up/run 时
#     container_name 默认是 `文件夹_服务_编号`
# 主机名
#     ubuntu hostname，存储在 /etc/hostname
#     docker hostname，默认是容器 ID
#         只对内部程序生效，用于内部程序需要引用一个固定的 hostname 的情况
#         无法改变外部的 DNS 和网络隔离，外部无法通过它来连接容器
    networks:
      existing_overlay_network:
        aliases:
          - kafka{{INDEX}}.{{ORDERERS_DOMAIN}}.com